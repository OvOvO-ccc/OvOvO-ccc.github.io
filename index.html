import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, mean_absolute_percentage_error
from tensorflow.keras.models import load_model
import matplotlib.dates as mdates
from matplotlib.animation import FuncAnimation

# Define the folder path
folder_path = 'C:/Users/13441/Desktop/SHAIXUAN.csv (2)/预测训练模型'

# List to store all dataframes
dataframes = []

# Loop through all files in the folder and load CSV files
for filename in os.listdir(folder_path):
    if filename.endswith('.csv'):
        file_path = os.path.join(folder_path, filename)
        df = pd.read_csv(file_path)
        dataframes.append(df)
        print(f"Loaded file: {filename}")

# Concatenate all dataframes into one if needed
data = pd.concat(dataframes, ignore_index=True)

# Extract relevant features
features = ['last', 'volume', 'position', 'ask1', 'bid1']
feature_data = data[features].values

# Data Preprocessing
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(feature_data)

# Prepare the dataset for LSTM
def create_dataset(data, time_step=120):
    X, Y = [], []
    for i in range(len(data) - time_step - 1):
        X.append(data[i:(i + time_step)])
        Y.append(data[i + time_step, 0])  # Predicting the closing price ('last')
    return np.array(X), np.array(Y)

# Set the time step
TIME_STEP = 120
X, Y = create_dataset(scaled_data, TIME_STEP)

# Reshape data to fit LSTM input requirements (samples, time steps, features)
X = X.reshape(X.shape[0], X.shape[1], len(features))

# Load the trained model
model_path = 'F:/code/预测训练模型/1saved_lstm_model.h5'
if os.path.exists(model_path):
    model = load_model(model_path)
    print("Model loaded from", model_path)
else:
    raise FileNotFoundError(f"Model file not found at {model_path}")

# Forecast future prices
def forecast_future(data, future_steps=200):
    last_sequence = data[-TIME_STEP:]
    forecast = []
    for _ in range(future_steps):
        input_sequence = last_sequence.reshape((1, TIME_STEP, len(features)))
        next_value = model.predict(input_sequence)[0, 0]
        forecast.append(next_value)
        # Update the sequence with the predicted value and update other feature values slightly
        new_features = last_sequence[-1, 1:] * (1 + np.random.uniform(-0.01, 0.01, len(features) - 1))  # Add slight random variation to other features
        next_sequence = np.append(last_sequence[1:], [[next_value] + list(new_features)], axis=0)
        last_sequence = next_sequence
    return scaler.inverse_transform(np.hstack((np.array(forecast).reshape(-1, 1), np.zeros((future_steps, len(features) - 1)))))[:, 0]

# Predict future prices for the next 200 data points
future_forecast = forecast_future(scaled_data)

# Create future time index for plotting future forecast (0.5 second intervals)
future_time_index = pd.date_range(start=pd.to_datetime(data['datetime']).iloc[-1], periods=200, freq='500ms')

# Save forecast data to CSV
output_data = pd.DataFrame({
    'Future Time': future_time_index,
    'Forecasted Price': future_forecast
})
output_file_path = 'C:/Users/13441/Desktop/future_forecast_output.csv'
output_data.to_csv(output_file_path, index=False)
print(f"Future forecast data has been saved to {output_file_path}")

# Set up the figure and axis for animation
fig, ax = plt.subplots(figsize=(14, 5))
ax.set_title('Future Stock Price Forecast (Next 200 Data Points)')
ax.set_xlabel('Time')
ax.set_ylabel('Closing Price')
ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
plt.xticks(rotation=45)
line, = ax.plot([], [], color='green', label='Future Forecast')
ax.legend()

# Initialization function for the animation
def init():
    line.set_data([], [])
    return line,

# Animation function to update the line with each frame
def animate(i):
    x = future_time_index[:i]
    y = future_forecast[:i]
    line.set_data(x, y)
    ax.set_xlim(future_time_index[0], future_time_index[-1])
    ax.set_ylim(min(future_forecast), max(future_forecast))
    return line,

# Create the animation
ani = FuncAnimation(fig, animate, init_func=init, frames=len(future_forecast), interval=100, blit=True)

# Display the animation
plt.show()
